\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{color}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage[colorlinks=true, linkcolor=black]{hyperref}
%\usepackage{makeidx}
%\usepackage{float}
\usepackage{wrapfig}
\usepackage{calc}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsfonts}
%\lstset{language=C}
\definecolor{gray}{gray}{0.5}
\definecolor{light-gray}{gray}{0.95}
\definecolor{orange}{rgb}{1,0.5,0}

\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}
\usepackage{float}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}





\newcommand{\cod}[1]{{\tt #1}}
\newcommand{\negro}[1]{{\bf #1}}
\newcommand{\ital}[1]{{\em #1}}
\newcommand{\may}[1]{{\sc #1}}
\newcommand{\tab}{\hspace*{2em}}

\hypersetup{
 pdfstartview= {FitH \hypercalcbp{\paperheight-\topmargin-1in-\headheight}},
 pdfauthor={Grupo},
 pdfsubject={Dise\~{n}o}
}

\lstdefinestyle{customc}{
  backgroundcolor=\color{light-gray},
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  numbers=left,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{gray},
  identifierstyle=\color{black},
  stringstyle=\color{orange},
}

\lstdefinestyle{customasm}{
  backgroundcolor=\color{light-gray},
  belowcaptionskip=1\baselineskip,
  numbers=left,
  xleftmargin=\parindent,
  language=[x86masm]Assembler,
  keywordstyle=\bfseries\color{blue},
  basicstyle=\footnotesize\ttfamily,
  commentstyle=\itshape\color{gray},
}

\lstset{escapechar=@}


\begin{document}

\thispagestyle{empty}
\materia{Métodos Numéricos}
\submateria{Segundo Cuatrimestre de 2015}
\titulo{Trabajo Práctico I}
%\subtitulo{Scheduling}
\integrante{Yanet Giuseppin}{184/11}{yanetagiu@yahoo.com}
\integrante{Laura Muiño}{399/11}{mmuino@dc.uba.ar}
\integrante{Javier San Miguel}{786/10}{javiersm00@fmail.com}
\integrante{Axel Straminsky}{769/11}{axelstraminsky@gmail.com}

\makeatletter

\maketitle
\newpage

\thispagestyle{empty}
\vfill

\thispagestyle{empty}
\vspace{3cm}
\tableofcontents
\newpage

\newenvironment{myindentpar}[1]
{\begin{list}{1}
         {\setlength{\leftmargin}{#1}}
         \item[]
}
{\end{list} }

%\normalsize
\newpage

% -------------------------------------------------------
% Breve explicacion de la base teorica que fundamenta los metodos involucrados en el trabajo, junto con los metodos mismos.  
% -------------------------------------------------------
\input{intro.tex}

\newpage
% ------------------------------------------------------
% Análisis de los coef. de la fórmula temperatura.
% -------------------------------------------------------
\input{desarrollo.tex}



\newpage
\bibliographystyle{plain}
\bibliography{tp3}

\newpage

\begin{algorithm}
\caption{Eliminación Gaussiana}\label{euclid}
\begin{algorithmic}[1]

  \Function{GaussianElimination}{A, b}\Comment{con $A \in R^{(nxm)*(nxm)}$, $b \in R^{nxm}$}

    \State $\textit{U} = \text{A.clone()}$

    \For {$actual\_row = 0$ to $U.rows() - 2$}
      \If {$U(actual\_row, actual\_row) == 0$} 
        \Return
      \EndIf

      \For {$row = actual\_row + 1$ to $U.rows() - 1$}
          \State $coefficient = U(row, actual\_row) / U(actual\_row, actual\_row)$
          \For {$col = actual\_row$ to $U.cols() - 1$}
            \If {$col == actual\_row$}  
              \State $U(row,col) = 0$
            \Else
              \State $U(row, col) = U(row, col) - coefficient * U(actual\_row, col)$
            \EndIf
          \EndFor

          \State $b(row) = b(row) - (coefficient * b(actual\_row)$
      \EndFor    
    \EndFor

  \EndFunction

\end{algorithmic}
\end{algorithm}




\begin{algorithm}
\caption{Backward Substitution}\label{euclid}
\begin{algorithmic}[1]

  \Function{Backward Substitution}{U, b}\Comment{con $U \in R^{(nxm)*(nxm)}$, $b \in R^{nxm}$}

    \State $\textit{X} = \text{Mat(U.rows())}$

    \For {$i = U.rows() - 1$ to $0$}
      \State $acum = 0.0$

      \For {$j = i+1$ to $U.rows() - 1$} 
        \State $acum = acum + U(i, j) * X(j)$
      \EndFor

      \State $X(i) = b(i) - acum / U(i, i)$

    \EndFor
      
  \EndFunction

\end{algorithmic}
\end{algorithm}




\begin{algorithm}
\caption{Backward Substitution LU}\label{euclid}
\begin{algorithmic}[1]

  \Function{Backward Substitution LU}{LU, b}\Comment{con $LU \in R^{(nxm)*(nxm)}$, $b \in R^{nxm}$}

    \State $\textit{X} = \text{Mat(LU.rows())}$
    \State $X(0) = b(0)$

    \For {$i = 1$ to $LU.rows() - 1$}
      \State $X(i) = b(i)$

      \For {$j = 0$ to $i - 1$} 
        \State $X(i) = X(i) - LU(i,j)*X(j)$
      \EndFor

    \EndFor
      
  \EndFunction

\end{algorithmic}
\end{algorithm}




\begin{algorithm}
\caption{Generación de Matriz LU}\label{euclid}
\begin{algorithmic}[1]

  \Function{GetLU}{A, LU}\Comment{con $A \in R^{(nxm)*(nxm)}$, $LU \in R^{(nxm)*(nxm)}$}

    \State $\textit{LU} = \text{A.clone()}$

    \For {$actual\_row = 0$ to $LU.rows() - 2$}
      \If {$LU(actual\_row, actual\_row) == 0$} 
        \Return
      \EndIf

      \For {$row = actual\_row + 1$ to $LU.rows() - 1$}
          \State $coefficient = LU(row, actual\_row) / LU(actual\_row, actual\_row)$
          \For {$col = actual\_row$ to $LU.cols() - 1$}
            \If {$col == actual\_row$}  
              \State $LU(row,col) = coefficient$
            \Else
              \State $LU(row, col) = LU(row, col) - coefficient * LU(actual\_row, col)$
            \EndIf
          \EndFor

      \EndFor    
    \EndFor

  \EndFunction

\end{algorithmic}
\end{algorithm}





\begin{algorithm}
\caption{Obtención del radio de la isoterma}\label{euclid}
\begin{algorithmic}[1]

  \Function{getIsotermRadiusValues}{X, angles, isoterm, delta_r, ri}

  \Comment{con $X \in R^{nxm}$, $angles \in N$, $isoterm, delta\_r, ri \in R$}

    \State $double isotermRadious[angles]$

    \For {$i = 0$ to $angles - 1$}
      \State $isotermRadius[i] = -1$
    \EndFor

    \For {$i = 0$ to $X.rows() - angles - 1$}
      \If {$X(i) >= isoterm \wedge X(i+angles) <= isoterm$}
       \State $isotermRadius[i \% angles] = (ri + (i / angles)*delta\_r + (((X(i) - isoterm) * delta_r)/ (X(i) - X(i+angles)) ))$
      \EndIf
    \EndFor

  \EndFunction

\end{algorithmic}
\end{algorithm}

\newpage


%CHAMUYO GRAFICOS


Los casos de test fueron generados con el programa \textit{generatetest.py}. En estos, el ángulo fue fijado en $10$, y el radio ($m$) fue variando entre $5$ y $80$. Los mismos fueron corridos en una CPU Intel I5-760 de 2.80 Ghz.

Para medir el tiempo, corrimos $40$ instancias para cada $m$ y tomamos el promedio, para evitar que la presencia de outliers influyera de manera significativa en los tiempos de ejecución. No tuvimos en cuenta los tiempos de carga.

En el gráfico 1 (tiempoEGdivididoM2), lo que hicimos fue dividir el tiempo de ejecución ($O(m^{3})$) por $m^{2}$, para de esta manera obtener el gráfico de una recta y probar efectivamente que el tiempo de ejecución real del algoritmo es el dicho anteriormente.

En el gráfico 2 (tiempoLUdivididoM), lo que hicimos fue considerar 2 casos: contando el tiempo de obtención de las matrices L y U, y sin contarlo. En ambos casos dividimos el tiempo de ejecución por $m$. En el primer caso, al dividir por $m$, el gráfico crece de manera parabólica, ya que el tiempo que tarda el algoritmo en obtener las matrices L y U es $O(m^{3})$. Por lo tanto, al dividir por m, el tiempo de ejecución debería crecer de forma cuadrática, lo cual se puede observar en el gráfico. 

En el segundo caso no se tuvo en cuenta el tiempo de obtención de las matrices L y U, por lo tanto el tiempo de ejecución del algoritmo es $O(m^{2})$, y al dividir todo por $m$, obtenemos una recta, como se puede observar.

En el gráfico 3 (tiempoLUyEGsinDividir), lo que hicimos fue comparar directamente el tiempo de ejecución de la eliminación gaussiana contra el tiempo de ejecución de LU (contando el tiempo de obtención de las matrices). En este caso los tiempos de ejecución no fueron divididos por $m$ ya que solamente queríamos poder comparar a grandes rasgos las diferencias entre los tiempos de ejecución de ambos algoritmos. Por más que ambos algoritmos son $O(m^{3})$, se puede observar que la eliminación gaussiana toma considerablemente más tiempo, lo cual nos confirma empíricamente la importancia de guardarnos las matrices L y U a la hora de resolver un sistema de ecuaciones.

\input{resultados.tex}
\end{document}

